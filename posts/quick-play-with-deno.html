<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="../main.css">
	<title>itanglo | Exploring the craft of web development</title>
</head>
<body>
	<h2>Quick play with Deno ðŸ¦•</h2>
	<p>Posted by Paolo on 7th October 2020</p>
	<p><a href="https://deno.land/">Deno</a> was released earlier this year and I thought I would have a quick play to get familiar with it. Deno is a JavaScript and TypeScript runtime made by the creator of Node.js, Ryan Dahl. It has more of a focus on security, not allowing reading of the file system or network access by default, instead allowing the user to control this using runtime flags like <code>--allow-read</code> and <code>--allow-net</code>. The other cool thing is that you can use the ES module syntax to import modules and even import external resources using a URL. Thanks to this feature the concept of the package.json file has been scrapped and all dependencies are cached and compiled by Deno. If you want to ensure you get the latest version of an external module you can run Deno again using <code>--reload</code> which will make a new request for the module and update the cache. The API feels quite intuitive to use, the error messages are clear and it is possible to get started with a simple example quickly.</p>
	<p>One of the things that I used to do with Node was watch files for changes and then re-run a particular task. To do this I had to normally include an extra dependency like node-watch. With Deno this is possible out of the box using the <code>--watch</code> flag. I headed over to the <a href="https://deno.land/manual@v1.4.4/getting_started/installation">installation guide</a> and followed along to get setup. Then I tried the example below to make sure the installation was successful:</p>
	<p><code>deno run https://deno.land/std/examples/welcome.ts</code></p>
	<p>If all goes well you should have seen a message saying "Welcome to Deno ðŸ¦•". The module which is being executed is external and if you visit the url you can see it consists of a simple <code>console.log()</code> statement. There are a variety of <a href="https://deno.land/std@0.73.0">standard Deno modules</a> available which augment the existing Deno API.</p>
	<p>Once I installed Deno, I created a sample project directory and within it I created a file called denoTest.js. <strong>Important:</strong> The first name I used for the file was test.js, but this had some funny side effects, particularly when it came to caching imported dependencies. I think this is because it clashed with one of the Deno commands named test. Then I created another file called dep1.js and in that I exported a simple string value as shown below:</p>
	<p><pre><code>export default 'Foo!';</code></pre></p>
	<p>Back in the denoTest.js file I imported the dep1.js default value and logged this to the console as shown below:</p>
<p><pre><code>import val from './dep1.js';
console.log('The value from dep1 is: ', val);</code></pre></p>
	<p>Finally all that remains to be done is to run the denoTest.js file using Deno.</p>
	<p><code>deno run --unstable --watch denoTest.js</code></p>
	<p>I had to also add the <code>--unstable</code> flag because Deno complained when I didn't use that in combination with the <code>--watch</code> flag. The description in the docs suggests that this flag allows you enable unstable APIs. I assume this is necessary when files are changing because APIs could potentially become unstable? Anyhow, when you run that command you should find that if you make any changes to the dep1.js file, the denoTest.js file is executed again. So if you were to change the value exported from 'Foo' to 'Bar', you should find that the value logged in the console is updated to reflect that.</p>
</body>
</html>